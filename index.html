<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stra√üenwacht: Connected</title>
    <style>
        :root {
            --bg-color: #0f172a; /* Deep Space Blue */
            --card-bg: #1e293b;
            --text-primary: #f8fafc;
            /* Neues Gelb Schema (#ffcd00 Basis) */
            --accent-color: #ffcd00; 
            --accent-dark: #e6b800; /* Etwas dunkler f√ºr Kontraste */
            --accent-glow: rgba(255, 205, 0, 0.5);
            
            --danger-color: #ef4444;
            --success-color: #10b981;
            --tech-blue: #3b82f6; /* F√ºr den Connected Car Modus */
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            background-color: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: var(--text-primary);
            padding: 20px;
            /* Retro Grid Hintergrund */
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
        }

        .game-card {
            background: var(--card-bg);
            width: 100%;
            max-width: 900px;
            border-radius: 24px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.05);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        /* Spiel Bereich */
        .game-container {
            width: 100%;
            height: 600px;
            background-color: #334155;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- UI OVERLAYS (Retro Style) --- */
        .overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(15, 23, 42, 0.9); /* Fast undurchsichtig */
            backdrop-filter: blur(10px);
            z-index: 20;
            padding: 20px;
            transition: opacity 0.3s;
        }
        
        /* Scanline Effekt */
        .overlay::after {
            content: "";
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: -1;
        }

        /* Animierter Titel */
        @keyframes glowPulse {
            0%, 100% { text-shadow: 0 0 20px var(--accent-glow); transform: scale(1); }
            50% { text-shadow: 0 0 40px var(--accent-glow); transform: scale(1.02); }
        }

        .game-title {
            font-size: 3.5rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: -2px;
            margin-bottom: 0;
            text-align: center;
            line-height: 1;
            /* Gradient Text */
            background: linear-gradient(to bottom right, #ffcd00, #fbbf24);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 15px rgba(255, 205, 0, 0.3));
            animation: glowPulse 3s infinite ease-in-out;
        }

        .game-subtitle {
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.2rem;
            color: #94a3b8;
            margin-top: 10px;
            margin-bottom: 30px;
            text-transform: lowercase;
            letter-spacing: 2px;
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 5px;
        }

        /* Leaderboard Panel */
        .leaderboard-panel {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            width: 100%;
            max-width: 380px;
            margin-bottom: 30px;
        }

        .leaderboard-header {
            text-transform: uppercase;
            font-size: 0.75rem;
            font-weight: bold;
            letter-spacing: 1.5px;
            color: #64748b;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            padding-bottom: 5px;
        }

        .leaderboard-list {
            max-height: 160px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #475569 transparent;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            border-radius: 4px;
        }
        .leaderboard-item:nth-child(odd) { background: rgba(255,255,255,0.03); }
        .rank { color: var(--accent-color); font-weight: bold; width: 30px; }
        .name { flex-grow: 1; color: #cbd5e1; }
        .score { color: var(--success-color); font-weight: bold; }

        /* DIAGNOSTIC OVERLAY (Connected Car) */
        .diag-container {
            width: 100%;
            max-width: 500px;
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid var(--tech-blue);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.3);
            position: relative;
            overflow: hidden;
            display: none; /* Hidden during boot sequence */
        }
        
        /* Boot Sequence Styles */
        .boot-container {
            width: 100%;
            max-width: 600px;
            padding: 20px;
            font-family: 'Courier New', monospace;
            color: var(--tech-blue);
            font-size: 1.1rem;
            text-align: left;
            text-shadow: 0 0 5px var(--tech-blue);
        }
        .terminal-cursor {
            display: inline-block;
            width: 10px;
            height: 18px;
            background-color: var(--tech-blue);
            animation: blink 1s step-end infinite;
            vertical-align: text-bottom;
        }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        .diag-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--tech-blue);
            padding-bottom: 10px;
            margin-bottom: 20px;
            color: var(--tech-blue);
            font-family: monospace;
            font-size: 0.9rem;
        }
        .diag-blink { animation: blink 1s infinite; }
        
        .diag-question {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 20px;
            line-height: 1.4;
            color: #fff;
        }
        
        .diag-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .diag-option {
            padding: 12px 15px;
            background: rgba(255,255,255,0.05);
            border: 1px solid #475569;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: monospace;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
        }
        
        .diag-option.selected {
            background: rgba(59, 130, 246, 0.2);
            border-color: var(--tech-blue);
            color: white;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.2);
        }
        
        .diag-option-key {
            background: #1e293b;
            color: var(--tech-blue);
            padding: 2px 6px;
            border-radius: 4px;
            margin-right: 10px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .diag-confirm-btn {
            margin-top: 20px;
            width: 100%;
            padding: 12px;
            background: var(--tech-blue);
            color: #0f172a;
            font-weight: bold;
            font-family: monospace;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 1rem;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.4);
            transition: all 0.2s;
        }
        .diag-confirm-btn:active {
            transform: scale(0.98);
            opacity: 0.9;
        }

        /* Start Button / Prompt */
        .start-btn {
            background: var(--accent-color);
            color: #0f172a;
            font-size: 1.1rem;
            font-weight: 800;
            padding: 12px 32px;
            border-radius: 99px;
            border: none;
            cursor: pointer;
            box-shadow: 0 0 20px var(--accent-glow);
            transition: transform 0.2s, box-shadow 0.2s;
            text-transform: uppercase;
            animation: bounce 2s infinite;
        }
        .start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px var(--accent-glow);
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {transform: translateY(0);}
            40% {transform: translateY(-5px);}
            60% {transform: translateY(-3px);}
        }

        /* Footer */
        .card-footer {
            padding: 20px 30px;
            background-color: #0f172a;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid rgba(255,255,255,0.05);
            font-size: 0.8rem;
            color: #475569;
        }

        /* Input Styles */
        .highscore-input {
            background: rgba(0,0,0,0.5);
            border: 1px solid #475569;
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 1.2rem;
            text-align: center;
            width: 100%;
            max-width: 250px;
            margin-bottom: 15px;
        }
        .highscore-input:focus { outline: 2px solid var(--accent-color); border-color: transparent; }

        /* HUD */
        #scoreBoard {
            position: absolute;
            top: 24px; right: 24px;
            font-family: 'Courier New', monospace;
            font-weight: 900;
            font-size: 28px;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            z-index: 5;
        }

        #repairBarContainer {
            position: absolute; width: 60px; height: 8px;
            background: #0f172a; border: 1px solid #94a3b8;
            border-radius: 4px; display: none; pointer-events: none; z-index: 5;
        }
        #repairBarFill {
            width: 0%; height: 100%; background: var(--success-color);
            border-radius: 2px; transition: width 0.1s linear;
        }

        @media (max-width: 600px) {
            .game-title { font-size: 2.5rem; }
            .game-container { height: 500px; }
            .card-footer { flex-direction: column; gap: 10px; text-align: center; }
        }
    </style>
</head>
<body>

    <div class="game-card">
        <div class="game-container" id="gameWrapper">
            <canvas id="gameCanvas"></canvas>
            
            <div id="scoreBoard">0</div>
            
            <div id="repairBarContainer">
                <div id="repairBarFill"></div>
            </div>

            <!-- START SCREEN -->
            <div id="startScreen" class="overlay">
                <h1 class="game-title">Stra√üenwacht<br>Connected</h1>
                <div class="game-subtitle">Digital liegenbleiben.</div>

                <div class="leaderboard-panel">
                    <div class="leaderboard-header">/// TOP EINSATZKR√ÑFTE ///</div>
                    <div class="leaderboard-list" id="startLeaderboard">
                        <div style="text-align:center; color:#64748b; padding:10px;">Verbinde mit Zentrale...</div>
                    </div>
                </div>

                <button class="start-btn" onclick="startGame()">Start Engine</button>
                
                <div style="margin-top: 20px; font-size: 0.8rem; color: #64748b;">
                    Steuerung: Pfeiltasten oder A / D
                </div>
            </div>

            <!-- DIAGNOSTIC OVERLAY (New) -->
            <div id="diagnosticOverlay" class="overlay" style="display: none; background: rgba(0,0,0,0.95); z-index: 30;">
                
                <!-- Boot Sequence Container -->
                <div id="bootSequence" class="boot-container" style="display: block;">
                    <div id="bootText"></div><span class="terminal-cursor"></span>
                </div>

                <!-- Main Diagnostic UI -->
                <div id="diagContainer" class="diag-container">
                    <div class="diag-header">
                        <span>> CONNECTED CAR INTERFACE</span>
                        <span class="diag-blink">‚óè LIVE</span>
                    </div>
                    
                    <div class="diag-question" id="diagQuestionText">
                        Fehleranalyse l√§uft...
                    </div>
                    
                    <div class="diag-options" id="diagOptionsList">
                        <!-- Options generated by JS -->
                    </div>
                    
                    <button class="diag-confirm-btn" onclick="resolveDiagnostic()">DIAGNOSE SENDEN [ENTER]</button>
                </div>
            </div>

            <!-- GAME OVER SCREEN -->
            <div id="gameOverScreen" class="overlay" style="display: none;">
                <h2 id="gameOverTitle" style="color: var(--danger-color); font-size: 2.5rem; text-transform: uppercase; margin-bottom: 10px;">Unfall!</h2>
                <p style="font-size: 1.1rem; color: #94a3b8; margin-bottom: 20px;">Score: <span id="finalScore" style="color: white; font-weight: bold;">0</span></p>
                
                <div id="newHighscoreForm" style="display: none; width: 100%; text-align: center;">
                    <p style="color: var(--success-color); font-weight: bold; margin-bottom: 15px; text-transform: uppercase; letter-spacing: 1px;">üèÜ Neuer Highscore!</p>
                    <input type="text" id="playerNameInput" class="highscore-input" placeholder="DEIN NAME" maxlength="10">
                    <br>
                    <button class="start-btn" style="font-size: 1rem; padding: 10px 24px;" onclick="submitScore()">Speichern</button>
                </div>

                <div id="gameOverLeaderboard" class="leaderboard-panel" style="display: none;">
                    <div class="leaderboard-header">/// RANGLISTE AKTUALISIERT ///</div>
                    <div class="leaderboard-list" id="gameOverLeaderboardList"></div>
                </div>

                <div style="margin-top: 30px;">
                    <p style="color: #64748b; cursor: pointer; text-decoration: underline;" onclick="resetGame()">Leertaste f√ºr Neustart</p>
                </div>
            </div>
        </div>

        <div class="card-footer">
            <div style="font-weight: 600;">
                built with ‚ù§Ô∏è by marcus and his ai team
            </div>
            <div style="opacity: 0.5; font-family: monospace;">
                ADAC_DEV_BUILD_2026
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('gameWrapper');
        
        // Screens
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const diagnosticOverlay = document.getElementById('diagnosticOverlay');
        
        // UI Elements
        const scoreBoard = document.getElementById('scoreBoard');
        const finalScoreDisplay = document.getElementById('finalScore');
        const repairBar = document.getElementById('repairBarContainer');
        const repairFill = document.getElementById('repairBarFill');
        const startLeaderboard = document.getElementById('startLeaderboard');
        const newHighscoreForm = document.getElementById('newHighscoreForm');
        const playerNameInput = document.getElementById('playerNameInput');
        const gameOverLeaderboard = document.getElementById('gameOverLeaderboard');
        const gameOverLeaderboardList = document.getElementById('gameOverLeaderboardList');
        
        // Diagnostic Elements
        const diagContainer = document.getElementById('diagContainer');
        const bootSequenceDiv = document.getElementById('bootSequence');
        const bootTextDiv = document.getElementById('bootText');
        const diagQuestionText = document.getElementById('diagQuestionText');
        const diagOptionsList = document.getElementById('diagOptionsList');

        // Game State
        let gameState = 'START'; // START, PLAYING, REPAIRING, BOOTING, DIAGNOSING, GAMEOVER
        let score = 0;
        let roadOffset = 0;
        let baseSpeed = 5; 
        let gameSpeed = baseSpeed;
        
        let currentLeaderboard = [];
        let repairsCount = 0; // Counter f√ºr Boss-Event
        
        // Diagnostic Logic
        let currentDiagQuestion = null;
        let diagSelectedIndex = 0;

        // Fragen Katalog (Connected Car Challenge) - ERWEITERT
        const diagnosticQuestions = [
            {
                scenario: "Motor startet nicht, Licht & Radio funktionieren nicht. Kein Anlasser-Ger√§usch.",
                options: ["Lichtmaschine defekt", "Batterie tiefentladen", "Z√ºndkerzen verschlissen", "Tank leer"],
                correct: 1
            },
            {
                scenario: "Motor √ºberhitzt, wei√üer Rauch steigt aus der Motorhaube auf.",
                options: ["K√ºhlmittelverlust", "Zu wenig √ñl", "Reifenpanne", "Klimaanlage defekt"],
                correct: 0
            },
            {
                scenario: "Warnleuchte '√ñlkanne' leuchtet rot auf.",
                options: ["Wischwasser leer", "Zu viel √ñl", "√ñldruck zu niedrig", "Bremsbel√§ge abgenutzt"],
                correct: 2
            },
            {
                scenario: "Fahrzeug zieht beim Bremsen stark nach links.",
                options: ["Radio zu laut", "Bremssattel fest", "Batterie schwach", "Auspuff undicht"],
                correct: 1
            },
            {
                scenario: "Blaue Wolke kommt beim Gasgeben aus dem Auspuff.",
                options: ["Motor verbrennt √ñl", "Wasser im Tank", "Katalysator neu", "Reifen drehen durch"],
                correct: 0
            },
            {
                scenario: "Lautes Klackern vorne beim Einlenken und Anfahren.",
                options: ["Hupe defekt", "Antriebswelle defekt", "Fenster offen", "Scheibenwischer trocken"],
                correct: 1
            },
            {
                scenario: "Motor l√§uft unrund, Motorkontrollleuchte blinkt gelb.",
                options: ["Z√ºndaussetzer", "Reifen platt", "Kofferraum offen", "Tank voll"],
                correct: 0
            },
            {
                scenario: "Reifen sind an den Au√üenkanten stark abgefahren.",
                options: ["Zu hoher Luftdruck", "Falsche Spur/Sturz", "Zu wenig Profil", "Felge rostig"],
                correct: 1
            },
            {
                scenario: "Motor geht w√§hrend der Fahrt einfach aus und springt nicht mehr an.",
                options: ["Lichtmaschine/Generator", "K√ºhlwasser leer", "Bremslicht defekt", "Radio Sicherung"],
                correct: 0
            },
            {
                scenario: "Schwarzer Rauch aus dem Auspuff bei Diesel-Fahrzeug.",
                options: ["Luftfilter verstopft/Turbo", "AdBlue leer", "Falsch getankt (Benzin)", "Z√ºndkerzen nass"],
                correct: 0
            },
            {
                scenario: "Kupplungspedal bleibt am Boden liegen.",
                options: ["Seilzug/Hydraulik defekt", "Gaspedal klemmt", "Bremsfl√ºssigkeit voll", "Batterie leer"],
                correct: 0
            },
            {
                scenario: "Fahrzeug vibriert stark ab 100 km/h im Lenkrad.",
                options: ["Unwucht in R√§dern", "Motorlager defekt", "Keilriemen lose", "Auspuff lose"],
                correct: 0
            },
            {
                scenario: "S√º√ülicher Geruch im Innenraum, Scheiben beschlagen.",
                options: ["W√§rmetauscher undicht", "Klimaanlage leer", "Duftbaum verfallen", "Fenster offen"],
                correct: 0
            },
            {
                scenario: "Auto springt morgens schlecht an, 'Vorgl√ºh'-Lampe blinkt.",
                options: ["Gl√ºhkerzen defekt", "Turbolader defekt", "√ñlwechsel f√§llig", "Reifendruck niedrig"],
                correct: 0
            },
            {
                scenario: "Gangschaltung l√§sst sich bei laufendem Motor schwer einlegen.",
                options: ["Kupplung trennt nicht", "Handbremse angezogen", "Lenkradsperre drin", "Licht an"],
                correct: 0
            },
            {
                scenario: "Metallisches Schleifen beim Bremsen.",
                options: ["Bremsbel√§ge runter", "Rost an der T√ºr", "Auspuff schleift", "Radlager defekt"],
                correct: 0
            },
            {
                scenario: "ESP-Leuchte brennt dauerhaft.",
                options: ["ABS/Drehzahlsensor", "Reifen zu neu", "Motor zu warm", "Radio kein Empfang"],
                correct: 0
            },
            {
                scenario: "Motor ruckelt stark beim Beschleunigen.",
                options: ["Kraftstofffilter zu", "Scheibenwasser leer", "Innenraumlicht an", "Reifen unwuchtig"],
                correct: 0
            },
            {
                scenario: "Schl√ºssel dreht sich nicht im Z√ºndschloss.",
                options: ["Lenkradschloss eingerastet", "Falscher Schl√ºssel", "Batterie leer", "Anlasser defekt"],
                correct: 0
            },
            {
                scenario: "Fahrzeugbeleuchtung flackert im Leerlauf.",
                options: ["Spannungsregler defekt", "Birne locker", "Radio zu laut", "Sicherung durch"],
                correct: 0
            }
        ];
        
        // Initial Fetch
        fetchLeaderboard();

        // Repair Logic
        let repairTimer = 0;
        const repairDuration = 50; 
        let currentTarget = null; 

        // Canvas Sizing
        function resizeCanvas() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        /* --- API FUNCTIONS --- */
        
        async function fetchLeaderboard() {
            try {
                const res = await fetch('/api/highscores');
                if (res.ok) {
                    currentLeaderboard = await res.json();
                    renderLeaderboard(currentLeaderboard, startLeaderboard);
                } else { throw new Error('API Offline'); }
            } catch (e) {
                if(currentLeaderboard.length === 0) {
                    renderLeaderboard([
                        { name: "GelberEngel", score: 150 },
                        { name: "PannenPro", score: 120 },
                        { name: "TrafficKing", score: 95 }
                    ], startLeaderboard);
                }
            }
        }

        async function submitScore() {
            const name = playerNameInput.value.trim();
            if (!name) return;

            try {
                const res = await fetch('/api/submit-score', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: name, score: score })
                });
                
                if (res.ok) {
                    newHighscoreForm.style.display = 'none';
                    gameOverLeaderboard.style.display = 'block';
                    const newData = await (await fetch('/api/highscores')).json();
                    currentLeaderboard = newData;
                    renderLeaderboard(newData, gameOverLeaderboardList);
                } else {
                    alert('Fehler beim Speichern.');
                }
            } catch (e) {
                console.error(e);
                newHighscoreForm.style.display = 'none';
                gameOverLeaderboard.style.display = 'block';
                renderLeaderboard([{name: name, score: score}, ...currentLeaderboard], gameOverLeaderboardList);
            }
        }

        function renderLeaderboard(data, target) {
            if (!data || data.length === 0) {
                target.innerHTML = '<div style="text-align:center; padding:10px; color:#64748b">Keine Daten</div>';
                return;
            }
            let html = '';
            data.forEach((entry, index) => {
                html += `
                    <div class="leaderboard-item">
                        <span class="rank">#${index + 1}</span>
                        <span class="name">${entry.name || entry.member}</span>
                        <span class="score">${entry.score}</span>
                    </div>
                `;
            });
            target.innerHTML = html;
        }

        function checkHighscore(finalScore) {
            const lowestScore = currentLeaderboard.length < 10 ? -1 : currentLeaderboard[currentLeaderboard.length - 1].score;
            gameOverLeaderboard.style.display = 'none';
            if (finalScore > lowestScore && finalScore > 0) {
                newHighscoreForm.style.display = 'block';
                setTimeout(() => document.getElementById('playerNameInput').focus(), 100);
            } else {
                newHighscoreForm.style.display = 'none';
                gameOverLeaderboard.style.display = 'block';
                renderLeaderboard(currentLeaderboard, gameOverLeaderboardList);
            }
        }

        /* --- DIAGNOSTIC MODE LOGIC --- */

        async function triggerDiagnosticMode() {
            gameState = 'BOOTING';
            diagnosticOverlay.style.display = 'flex';
            bootSequenceDiv.style.display = 'block';
            diagContainer.style.display = 'none';
            
            // Boot Animation - UPDATED TEXT
            const lines = [
                "> ESTABLISHING SECURE CONNECTION...",
                "> VERBINDUNG HERGESTELLT.",
                "> INITIALISIERE AMD...", // Insider Update
                "> FEHLERCODES ERKANNT.",
                "> BITTE DIAGNOSTIZIEREN SIE!"
            ];
            
            bootTextDiv.innerHTML = "";
            for (let line of lines) {
                await typeLine(line);
                await new Promise(r => setTimeout(r, 400));
            }
            
            await new Promise(r => setTimeout(r, 800));
            
            // Switch to Diagnostic Interface
            bootSequenceDiv.style.display = 'none';
            diagContainer.style.display = 'block';
            gameState = 'DIAGNOSING';
            
            // Pick Random Question
            currentDiagQuestion = diagnosticQuestions[Math.floor(Math.random() * diagnosticQuestions.length)];
            diagSelectedIndex = 0;
            
            // Render
            diagQuestionText.textContent = currentDiagQuestion.scenario;
            renderDiagOptions();
        }
        
        function typeLine(text) {
            return new Promise(resolve => {
                const p = document.createElement('div');
                bootTextDiv.appendChild(p);
                let i = 0;
                const interval = setInterval(() => {
                    p.textContent += text.charAt(i);
                    i++;
                    if (i >= text.length) {
                        clearInterval(interval);
                        resolve();
                    }
                }, 30); // Typing speed
            });
        }

        function renderDiagOptions() {
            diagOptionsList.innerHTML = '';
            currentDiagQuestion.options.forEach((opt, idx) => {
                const el = document.createElement('div');
                el.className = `diag-option ${idx === diagSelectedIndex ? 'selected' : ''}`;
                el.innerHTML = `<span class="diag-option-key">${idx + 1}</span> ${opt}`;
                el.onclick = () => { diagSelectedIndex = idx; renderDiagOptions(); }; // Mouse support
                diagOptionsList.appendChild(el);
            });
        }

        function resolveDiagnostic() {
            const isCorrect = diagSelectedIndex === currentDiagQuestion.correct;
            
            diagnosticOverlay.style.display = 'none';
            
            if (isCorrect) {
                score += 50;
                floatingTexts.push(new FloatingText(player.x, player.y - 60, "SYSTEM RECOVERED! +50", "#10b981")); // Green
            } else {
                score -= 50;
                floatingTexts.push(new FloatingText(player.x, player.y - 60, "SYSTEM FAILURE! -50", "#ef4444")); // Red
            }
            
            scoreBoard.textContent = score;
            
            // Resume Game
            gameState = 'PLAYING';
            spawnCar();
        }

        /* --- GAME ENGINE --- */
        const player = { x: 0, y: 0, width: 44, height: 75, speed: 8, color: '#ffcd00', type: 'towtruck' };
        let cars = [];
        let particles = []; 
        let floatingTexts = []; 

        class FloatingText {
            constructor(x, y, text, color) {
                this.x = x; this.y = y; this.text = text; this.color = color;
                this.life = 1.0; this.vy = -1.5; 
            }
            update() { this.y += this.vy; this.life -= 0.015; }
            draw() {
                ctx.save(); ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color; ctx.font = "bold 24px Arial";
                ctx.shadowColor = "rgba(0,0,0,0.8)"; ctx.shadowBlur = 4;
                ctx.textAlign = "center";
                ctx.fillText(this.text, this.x + 22, this.y); ctx.restore();
            }
        }

        class Car {
            constructor(isBroken) {
                this.width = 40; this.height = 65;
                this.x = Math.random() * (canvas.width - 50); this.y = -100;
                this.isBroken = isBroken;
                this.speed = isBroken ? 0.5 : (Math.random() * 2 + 3); 
                const colors = ['#3b82f6', '#10b981', '#8b5cf6', '#ec4899', '#ef4444', '#f97316'];
                this.color = isBroken ? '#64748b' : colors[Math.floor(Math.random() * colors.length)]; 
                this.repaired = false; this.blinkerState = false; this.blinkerTimer = 0;
            }
            update() {
                if (gameState === 'PLAYING') {
                    let moveSpeed = this.isBroken ? gameSpeed : (gameSpeed + this.speed * 0.5);
                    this.y += moveSpeed;
                }
                if (this.isBroken && !this.repaired) {
                    this.blinkerTimer++;
                    if (this.blinkerTimer > 8) { this.blinkerState = !this.blinkerState; this.blinkerTimer = 0; }
                    if (Math.random() > 0.6) particles.push(new Smoke(this.x + this.width/2, this.y + 10)); 
                }
            }
        }

        class Smoke {
            constructor(x, y) {
                this.x = x; this.y = y; this.size = Math.random() * 6 + 3;
                this.alpha = 0.6; this.vy = -1 - Math.random() * 1.5; this.vx = (Math.random() - 0.5) * 3;
            }
            update() { this.y += this.vy; this.x += this.vx; this.alpha -= 0.03; this.size += 0.15; }
            draw() {
                ctx.fillStyle = `rgba(148, 163, 184, ${this.alpha})`;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
            }
        }

        /* --- RENDER --- */

        function drawVehicle(x, y, w, h, color, type, blinkerOn) {
            ctx.save();
            ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(x + 8, y + 8, w, h);
            ctx.fillStyle = color; ctx.fillRect(x, y, w, h);

            if (type === 'towtruck') {
                ctx.fillStyle = '#e6b800'; ctx.fillRect(x, y, w, h * 0.35);
                ctx.fillStyle = '#1e293b'; ctx.fillRect(x + 4, y + h * 0.4, w - 8, h * 0.55);
                ctx.fillStyle = '#ffdb4d'; ctx.fillRect(x + 5, y + 5, w - 10, 4); 
                ctx.fillStyle = '#0f172a'; ctx.fillRect(x + 5, y + 10, w - 10, 10);

                if (gameState === 'REPAIRING') {
                    const time = Date.now() / 100;
                    const alpha = (Math.sin(time * 5) + 1) / 2 * 0.6 + 0.4;
                    const cx = x + w/2; const cy = y + 7;
                    const g = ctx.createRadialGradient(cx, cy, 5, cx, cy, 50);
                    g.addColorStop(0, `rgba(255, 205, 0, ${alpha})`);
                    g.addColorStop(1, 'transparent');
                    ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx, cy, 50, 0, Math.PI*2); ctx.fill();
                    ctx.shadowBlur=20; ctx.shadowColor='#ffcd00'; ctx.fillStyle='#ffe680'; 
                    ctx.beginPath(); ctx.arc(cx, cy, 5, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur=0;
                }
            } else {
                ctx.fillStyle = '#0f172a'; ctx.fillRect(x+4, y+12, w-8, 10);
                ctx.fillRect(x+4, y+h-18, w-8, 8);
                ctx.fillStyle = color; ctx.globalAlpha=0.9; ctx.fillRect(x+6, y+20, w-12, h-35); ctx.globalAlpha=1.0;
                ctx.fillStyle = '#fef3c7'; ctx.fillRect(x+2, y+h-5, 8, 4); ctx.fillRect(x+w-10, y+h-5, 8, 4);
            }

            if (blinkerOn) {
                ctx.fillStyle = '#f97316'; ctx.shadowBlur = 15; ctx.shadowColor = '#ea580c';
                ctx.fillRect(x-4, y, 8, 8); ctx.fillRect(x+w-4, y, 8, 8);
                ctx.fillRect(x-4, y+h-8, 8, 8); ctx.fillRect(x+w-4, y+h-8, 8, 8);
                ctx.shadowBlur = 0;
            }
            ctx.restore();
        }

        /* --- CONTROL & LOOP --- */

        function spawnCar() {
            if (gameState !== 'PLAYING') return;
            cars.push(new Car(Math.random() < 0.35));
            
            // PROGRESSIVE DIFFICULTY
            // Decrease spawn time based on repairs
            const difficultyFactor = Math.min(0.5, repairsCount * 0.02); // Cap at 50% reduction
            const minTime = 700 * (1 - difficultyFactor);
            const variance = 900 * (1 - difficultyFactor);
            setTimeout(spawnCar, Math.random() * variance + minTime);
        }

        function handleInput(type, code) {
            // DIAGNOSTIC MODE CONTROLS
            if ((gameState === 'DIAGNOSING' || gameState === 'BOOTING') && type === 'keydown') {
                if (gameState === 'BOOTING') return; // Lock inputs during boot
                if (code === 'ArrowUp') {
                    diagSelectedIndex = Math.max(0, diagSelectedIndex - 1);
                    renderDiagOptions();
                } else if (code === 'ArrowDown') {
                    diagSelectedIndex = Math.min(3, diagSelectedIndex + 1);
                    renderDiagOptions();
                } else if (code === 'Enter' || code === 'Space') {
                    resolveDiagnostic();
                }
                return; // Stop other inputs
            }

            if (type === 'keydown') {
                if (gameState === 'GAMEOVER' && code === 'Space') {
                    if (document.activeElement.tagName === 'INPUT') return;
                    resetGame();
                }
                if (gameState === 'START') startGame();
                if (code === 'ArrowLeft' || code === 'KeyA') player.moveLeft = true;
                if (code === 'ArrowRight' || code === 'KeyD') player.moveRight = true;
            }
            if (type === 'keyup') {
                if (code === 'ArrowLeft' || code === 'KeyA') player.moveLeft = false;
                if (code === 'ArrowRight' || code === 'KeyD') player.moveRight = false;
            }
        }
        window.addEventListener('keydown', e => handleInput('keydown', e.code));
        window.addEventListener('keyup', e => handleInput('keyup', e.code));

        let touchX = null;
        container.addEventListener('touchstart', e => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
            
            touchX = e.touches[0].clientX;
            if(e.cancelable && gameState === 'PLAYING') e.preventDefault();
        });
        
        container.addEventListener('touchmove', e => {
            if(touchX !== null && gameState === 'PLAYING') {
                const diff = e.touches[0].clientX - touchX;
                player.x += diff * 1.5;
                if(player.x < 0) player.x = 0; if(player.x > canvas.width - player.width) player.x = canvas.width - player.width;
            }
            touchX = e.touches[0].clientX;
            if(e.cancelable && gameState === 'PLAYING') e.preventDefault();
        });

        function startGame() {
            gameState = 'PLAYING'; startScreen.style.display = 'none';
            player.x = canvas.width/2 - player.width/2; player.y = canvas.height - 130;
            cars = []; particles = []; floatingTexts = []; score = 0;
            repairsCount = 0;
            gameSpeed = baseSpeed; // Reset speed
            scoreBoard.textContent = 0; scoreBoard.style.color = '#fff';
            spawnCar(); animate();
        }

        function resetGame() {
            gameOverScreen.style.display = 'none';
            diagnosticOverlay.style.display = 'none';
            fetchLeaderboard();
            startScreen.style.display = 'flex'; 
            gameState = 'START';
        }

        function startRepair(targetCar) {
            gameState = 'REPAIRING'; currentTarget = targetCar; repairTimer = 0;
            repairBar.style.display = 'block'; repairBar.style.left = (player.x - 8) + 'px'; repairBar.style.top = (player.y - 20) + 'px';
        }

        function finishRepair() {
            score += 10;
            repairsCount++;
            
            repairBar.style.display = 'none';
            if(currentTarget) { 
                currentTarget.repaired = true; 
                currentTarget.isBroken = false; 
                currentTarget.color = '#10b981'; 
                currentTarget.speed = 6; 
            }
            currentTarget = null; 
            scoreBoard.textContent = score; 
            
            // PROGRESSIVE DIFFICULTY: Increase speed every 5 repairs
            if (repairsCount % 5 === 0) {
                 gameSpeed = Math.min(12, baseSpeed + (repairsCount / 5) * 0.5);
                 floatingTexts.push(new FloatingText(player.x, player.y - 80, "LEVEL UP! FASTER!", "#f59e0b"));
            }

            // Trigger Diagnostic Mode every 20 repairs (UPDATED)
            if (repairsCount > 0 && repairsCount % 20 === 0) {
                triggerDiagnosticMode();
            } else {
                gameState = 'PLAYING';
                floatingTexts.push(new FloatingText(player.x, player.y - 40, "+10", "#10b981"));
                spawnCar();
            }
        }

        function crash(reason) {
            gameState = 'GAMEOVER'; finalScoreDisplay.textContent = score;
            const titleElement = document.getElementById('gameOverTitle');
            if (titleElement) titleElement.textContent = reason || "Unfall!";
            checkHighscore(score);
            gameOverScreen.style.display = 'flex'; repairBar.style.display = 'none';
            diagnosticOverlay.style.display = 'none';
        }

        function update() {
            particles.forEach((p, i) => { p.update(); if(p.alpha <= 0) particles.splice(i, 1); });
            floatingTexts.forEach((ft, i) => { ft.update(); if(ft.life <= 0) floatingTexts.splice(i, 1); });

            if (gameState === 'PLAYING') {
                roadOffset += gameSpeed; if (roadOffset > 40) roadOffset = 0;
                if (player.moveLeft && player.x > 0) player.x -= player.speed;
                if (player.moveRight && player.x < canvas.width - player.width) player.x += player.speed;

                cars.forEach((car, index) => {
                    car.update();
                    const padding = 6;
                    if (player.x + padding < car.x + car.width - padding && player.x + player.width - padding > car.x + padding && player.y + padding < car.y + car.height - padding && player.y + player.height - padding > car.y + padding) {
                        if (car.isBroken && !car.repaired) startRepair(car); else if (!car.isBroken && !car.repaired) crash("Unfall!");
                    }
                    if (car.y > canvas.height + 50) {
                        if (car.isBroken && !car.repaired) {
                            score -= 5; scoreBoard.textContent = score;
                            floatingTexts.push(new FloatingText(car.x + car.width/2 - 10, canvas.height - 40, "-5", "#ef4444"));
                            scoreBoard.style.color = '#ef4444';
                            if (score < 0) crash("Pannenquote!"); else setTimeout(() => { if(gameState === 'PLAYING') scoreBoard.style.color = '#fff'; }, 300);
                        }
                        cars.splice(index, 1);
                    }
                });
            } else if (gameState === 'REPAIRING') {
                repairTimer++; let pct = (repairTimer / repairDuration) * 100; repairFill.style.width = pct + '%';
                repairBar.style.left = (player.x - 8) + 'px';
                if (repairTimer >= repairDuration) finishRepair();
            }
        }

        function draw() {
            ctx.fillStyle = '#1e293b'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#334155'; ctx.lineWidth = 4; ctx.setLineDash([30, 40]); ctx.lineDashOffset = -roadOffset; 
            ctx.beginPath(); ctx.moveTo(canvas.width / 2, -50); ctx.lineTo(canvas.width / 2, canvas.height + 50); ctx.stroke();
            ctx.setLineDash([]); ctx.lineWidth = 8; ctx.strokeStyle = '#475569';
            ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(10, canvas.height); ctx.moveTo(canvas.width - 10, 0); ctx.lineTo(canvas.width - 10, canvas.height); ctx.stroke();

            cars.forEach(car => drawVehicle(car.x, car.y, car.width, car.height, car.color, 'car', car.blinkerState));
            player.y = canvas.height - 130;
            drawVehicle(player.x, player.y, player.width, player.height, player.color, 'towtruck', false);
            particles.forEach(p => p.draw()); floatingTexts.forEach(ft => ft.draw());
        }

        function animate() {
            if (gameState !== 'GAMEOVER') { update(); draw(); requestAnimationFrame(animate); }
        }

        // Init
        resizeCanvas(); player.y = canvas.height - 130; player.x = canvas.width/2 - 22; draw();

    </script>
</body>
</html>
